<!DOCTYPE html>
<html lang="zh-cmn-Hans">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <link rel="icon" type="image/x-icon" href="../icon/favicon.ico">
    <link rel="stylesheet" type="text/css" href="../css/all.css">
    <link rel="stylesheet" href="../css/highlight/styles/foundation.css">
    <title>图 | zbs's Blog</title>
  </head>
  <body>
    <header id="header">
      <div class="wraper">
        <div class="clearFix" id="logobar">
          <div class="logo">
            <div class="logo-line-before"> </div><a href="../index.html">zbs's Blog</a>
            <div class="logo-line-after"></div>
          </div>
          <div class="nav">
            <ul>
              <li><a href="../index.html">
                   <i class="fa fa-fw fa-home"></i>首页</a></li>
              <li><a href="./archive.html">
                   <i class="fa fa-fw fa-archive"></i>归档</a></li>
              <li><a href="../types/type.html">
                   <i class="fa fa-fw fa-th"></i>分类</a></li>
              <li><a href="../tags/tags.html">
                   <i class="fa fa-fw fa-tags"></i>标签</a></li>
            </ul>
          </div>
        </div>
      </div>
    </header>
    <main id="main">
      <div class="wraper clearFix">
        <div id="detail">
          <h1 class="title">图</h1>
          <p class="info"><span> <i class="fa fa-calendar-o"> </i> 发表于 2017-12-19 17:05:22 
               |  </span><span><i class="fa fa-folder-o"> </i> 分类于 算法
               | </span></p>
          <div class="markdown-body"><h2>图的相关概念</h2>
<ul>
<li>图，是网络结构的抽象模型。</li>
<li>图，是一组由边连接的节点（或顶点）。</li>
<li>任何二元关系都可以用图来表示</li>
</ul>
<h3>图，在数学及技术上的概念</h3>
<ul>
<li>一个图 G = ( V, E ) 由以下元素组成
<ul>
<li>V：一组顶点</li>
<li>E：一组边，连接 V 中的顶点</li>
</ul>
</li>
</ul>
<h3>术语</h3>
<ul>
<li>相邻顶点
<ul>
<li>由一条边连接在一起的顶点称为相邻顶点</li>
</ul>
</li>
<li>顶点的度
<ul>
<li>一个顶点的度，是其相邻顶点的数量</li>
</ul>
</li>
<li>路径
<ul>
<li>是顶点 v &lt;sub&gt;1&lt;/sub&gt; ，v&lt;sub&gt;2&lt;/sub&gt; ， ...v&lt;sub&gt;k&lt;/sub&gt; 的一个连续序列。</li>
<li>其中 v&lt;sub&gt;i&lt;/sub&gt; ， v&lt;sub&gt;i + 1&lt;/sub&gt; 是相邻的。</li>
</ul>
</li>
<li>简单路径
<ul>
<li>要求不包含重复的顶点</li>
</ul>
</li>
<li>环
<ul>
<li>环也是一个简单路径</li>
</ul>
</li>
<li>无环
<ul>
<li>如果图中不存在环，则称该图是无环的。</li>
</ul>
</li>
<li>连通
<ul>
<li>如果图中每两个顶点间都存在路径，则该图是连通的。</li>
</ul>
</li>
<li>有向图
<ul>
<li>有向图的边有一个方向</li>
</ul>
</li>
<li>无向图
<ul>
<li>图的边没有方向</li>
</ul>
</li>
<li>强连通
<ul>
<li>如果图中每两个顶点间在双向上都存在路径，则该图是强连通的。</li>
</ul>
</li>
<li>加权、未加权
<ul>
<li>图还可以是未加权的、或是加权的。</li>
</ul>
</li>
</ul>
<h2>图的表示</h2>
<h3>邻接矩阵</h3>
<ul>
<li>图最常见的实现是邻接矩阵</li>
<li>每个节点都和一个整数相关联，该整数最为数组的索引。</li>
<li>用一个二维数组来表示顶点之间的链接。</li>
<li>如果索引为 i 的节点和索引为 j 的节点相邻，则<code>array [ i ][ j ] === 1</code>，否则，<code>array [ i ][ j ] === 0</code></li>
<li>缺点
<ul>
<li>不是强连通的图（稀疏图），如果用邻接矩阵来表示，则矩阵中将会有很多 0，意味着浪费了存储空间来表示不存在的边。</li>
<li>例如，找给定顶点的相邻顶点，即使该顶点只有一个相邻顶点，也不得不迭代一整行。</li>
<li>图中顶点的数量可能会改变，而 二维数组不太灵活。</li>
</ul>
</li>
</ul>
<h3>邻接表</h3>
<ul>
<li>由图中每个顶点的相邻顶点列表组成。</li>
<li>可用列表（数组）、链表、散列表、字典，来表示相邻顶点列表。</li>
<li>邻接表可能对大多数问题来说都是更好的选择，但以上两种表示法都很有用，且它们有着不同的性质</li>
<li>例如，要找出顶点 v 和 w 是否相等，使用邻接矩阵会比较快。      ​</li>
</ul>
<h3>关联矩阵</h3>
<ul>
<li>矩阵的行表示顶点，列表时便。</li>
<li>如果顶点 v 是边 e 的入射点，则 <code>array [ v ] [ e ] === 1</code>，否则<code>array [ v ][ e ] === 0</code></li>
<li>关联矩阵通常用于边的数量比顶点多的情况，以节省空间和内存。</li>
</ul>
<h2>图的遍历</h2>
<h3>图遍历</h3>
<ul>
<li>可用来寻找特定的顶点或寻找两个顶点之间的路径</li>
<li>检检查图是否连通</li>
<li>检查图是否含有环等。</li>
</ul>
<h3>广度优先搜索（Breadth-First Search，BFS）</h3>
<ul>
<li>从指定的一个顶点开始遍历图</li>
<li>先访问其所有的相邻点，就像一次访问图的一层。就是宽后深地访问顶点。</li>
</ul>
<h3>深度优先搜索（Depth-First Search，DFS）</h3>
<ul>
<li>从第一个指定的顶点开始遍历图</li>
<li>沿着路径直到这条路径最后一个顶点被访问了</li>
<li>接着原路退回 。并探索下一跳路径。</li>
<li>先深度后广度地访问顶点。</li>
</ul>
<h3>图遍历算法的思想</h3>
<ul>
<li>必须追踪每个第一次访问的节点</li>
<li>并且追踪哪些节点还没有被完全探索。</li>
<li>对于两种图遍历算法，都需要明确指出第一个被访问的顶点。</li>
<li>完全探索一个顶点
<ul>
<li>要求查看该顶点的每一条边</li>
<li>对于每一条边所连接的没有被访问过的顶点，将其标注为被发现的，并将其加进待访问顶点列表中。</li>
</ul>
</li>
<li>为保证算法的效率，访问每个顶点至多两次。</li>
<li>当要标注已经访问过的顶点时，用三种颜色反应它们的状态
<ul>
<li>白色：表示该顶点还未被访问</li>
<li>灰色：表示该顶点被访问过，但还未被探索过</li>
<li>黑色：表示该顶点被访问过且被完全探索过。</li>
</ul>
</li>
</ul>
<h3>广度优先搜索、深度优先搜索对比</h3>
<table>
<thead>
<tr>
<th>算法</th>
<th>描述</th>
<th>数据结构</th>
</tr>
</thead>
<tbody>
<tr>
<td>深度优先搜索</td>
<td>栈</td>
<td>通过将顶点存入栈中，顶点是沿着路径被探索的，存在新的相邻顶点就去访问</td>
</tr>
<tr>
<td>广度优先搜索</td>
<td>队列</td>
<td>通过将顶点存入队列中，最先入队列的顶点先被探索。</td>
</tr>
</tbody>
</table>
<h2>图的创建</h2>
<pre><code class="language-javascript">function Grap ( ) {
  	//用一个数组来存储图中所有顶点
  	//用一个字典存储邻接表
  	var vertices = [ ] ;
  	var adjList = new Dictionary ( ) ;
  
  	// 向图中添加一个新顶点
  	this.addVertex = function ( v ) {
      	vertices.push( v ) ;
      	adjList.set ( v, [ ] ) ;s
  	} ;
  
  	// 添加顶点之间的边
  	this.addEdge = function ( v, w ) {
      	adjList.get ( v ).push ( w ) ;
     	adjList.get ( w ).push( v ) ;
  	} ;
  
  
  	this.toString = function ( ) {
      	var s = &quot; &quot; ;
      	for ( var i = 0; i &lt; vertices.length; i++ ) {
          	s += vertices [ i ]  + &quot; -&gt; &quot; ;
          	var neighbors = adjList.get ( vertices [ i ] ) ;
          	for ( var j = 0; j &lt; neighbors.length; j++ ) {
              	s += neighbors [ j ] ;
          	}
          	s += &quot; \n &quot; ;
      	}
  	} ;
  
  // 广度优先搜索
  	 // 创建一个队列 Q
  	 // 将 v 标注为被发现的（灰色），并将 v 入队列 Q
  	 // 如果 Q 非空，则运行一下步骤
  		// 1）将 u 从 Q 中出队列
  		// 2）将标注 u 为被发现的（灰色）
  		// 3）将 u 所有未被访问过的临点（白色）入队列；
  		// 4）将 u 标注为已被探索的（黑色）。
  	 var initializeColor = function ( ) {
       	var color = [ ] ;
       	for ( var i = 0; i &lt; vertices.length; i++ ) {
          	color [ vertices [ i ] ] = &quot;white&quot; ;
       	}
       	return color ;
  	 } ;
  	 
  	 this.bfs = function ( v, callback ) {
       	var color = initializeColor ( ) ,
            queue = new Queue ( ) ;
       queue.enqueue ( v ) ;
       
       while ( ! queue.isEmpty ( ) ) {
         	var u = queue.dequeue ( ) ,
                neighbors = adjList.get ( u ) ;
         	color [ u ] = &quot;grey&quot; ;
         	for ( var i = 0; i &lt; negihbors.length; i++ ) {
              	var w = neighbors [ i ] ;
              	if ( color [ w ] === &quot;white&quot;) {
                  	color [ w ] = &quot;grey&quot; ;
                  	queue.enqueue ( w ) ;
              	}
         	}
         	color [ u ] = &quot;black&quot; ;
         	if ( callback ) {
              	callback ( u ) ;
         	}
       }
  	 } ;
  
  
  // 深度优先搜索
  	 // 并不需要一个源顶点
  	 // 若图中顶点 v 未访问，则访问该顶点 v
  	 // 要访问顶点 v ，步骤如下：
  		// 1）标注 v 为被发现的（灰色）
  		// 2）对于 v 的所有未访问的邻点 w：
  			// 访问顶点 w
  		// 3）标注 v 为已探索的（黑色）
  	 this.dfs = function ( callback ) {
       	var color = initializeColor ( ) ;
       	for ( var i = 0; i &lt; vertices.length; i++ ) {
          	if ( colo [ vertices [ i ] ] === &quot;white&quot; ) {
              	dfsVisit ( vertices [ i ], color, callback ) ;
          	} 
       	}
  	 } ;
  
  	// 辅助函数 dfsVisit
  	var dfsVisit = function ( u, color, callback ) {
      	color [ u ] = &quot;grey&quot; ;
      	if ( callback ) {
          	callback ( u ) ;
      	}
      	var neighbors = adjList.get ( u ) ;
      	for ( var i = 0; i &lt; neighbors.length; i++ ) {
          	var w = neighbors [ i ] ;
          	if ( color [ w ] === &quot;white&quot;) {
              	dfsVisit ( w, color, callback ) ;
          	}
      	}
      	color [ u ] = &quot;black&quot; ;
  	} ;
  
  
}
</code></pre>
<h2>使用 BFS 寻找最短路径</h2>
<ul>
<li>
<p>给定一个图 G 和源顶点 v ，找出对每个顶点 u ，u 和 v 之间最短路径的距离（以边的数量计）。</p>
</li>
<li>
<p>对于给定顶点 v ，广度优先算法会访问所有与其距离为 1 的顶点，接着是距离为 2 的顶点，以此类推。</p>
</li>
<li>
<p>所以，可以用广度优先算法来接这个问题。</p>
</li>
<li>
<p>修改 bfs 方法以返回一些信息。</p>
<ul>
<li>从 v 到 u 的距离 d [ u ] ；</li>
<li>前溯点 pred [ u ] ，用来推导出从 v 到其他每个顶点s u 的最短路径。</li>
</ul>
</li>
</ul>
<pre><code class="language-javascript">  this.BFS = function ( v ) {
    	
    	var color = initializeColor ( ) ,
          queue = new Queue ( ) ,
          d = [ ] ,
          pred = [ ] ;
    queue.enqueue ( v ) ;
    
    for ( var i = 0; i &lt; vertices.length; i++ ) {
      	d [ vertices [ i ] ] = 0 ;
      	pred [ vertices [ i ] ] = null ;
    }
    
    while ( ! queue.isEmpty ( ) ) {
      	var u = queue.dequeue ( ) ,
              neighbors = adjList.get ( u ) ;
      color [ u ] = &quot;grey&quot; ;
      for ( i = 0; i &lt; neighbors.length; i ++ ) {
        	var w = neighbors [ i ] ;
        	if ( color [ w ] === &quot;white&quot; ) {
            	color [ w ] = &quot;grey&quot; ;
            	d [ w ] = d [ u ] + 1 ;
            	pred [ w ] = u ;
            	queue.enqueue ( w ) ;
        	}
      }
      color [ u ] = &quot;black&quot; ;
    }
    return {
      	distances : d,
      	predecessors :pred 
    } ;
    
  } ;
</code></pre>
<h2>深入学习最短路径算法</h2>
<ul>
<li>本章中的图不是加权图</li>
<li>如果计算加权图中的最短路径（例如，城市 A 和城市 B 之间的最短路径——GPS 和 Google Maps 中用到的算法），广度优先搜索未必合适</li>
<li>Dijkstra's 算法解决了单源最短路径问题</li>
<li>Bellman-Ford 算法解决了边权值为负的单源最短路径问题</li>
<li>A* 搜索算法解决了求仅一对顶点间的最短路径问题，它用经验法则来加速搜索过程。</li>
<li>Floyd-Warshall 算法解决了求所有顶点对间的最短路径问题</li>
</ul>
<h2>探索深度优先算法</h2>
<ul>
<li>对于给定的图 G ，
<ul>
<li>希望深度优先搜索算法遍历图 G 的所有节点，构建 ”森林“ （有根树的一个集合）以及一组源顶点（根），</li>
<li>并输出两个数组：
<ul>
<li>发现时间</li>
<li>完成探索时间</li>
</ul>
</li>
<li>可以修改 dfs 方法来返回一些信息：
<ul>
<li>顶点 u 的发现事件 d [ u ]</li>
<li>当顶点 u 被标注为黑色时， u 的完成探索实践 f [ u ]</li>
<li>顶点 u 的前溯点 p [ u ]</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="language-javascript">    var time = 0 ;
    this.DFS = function ( ) {
      	var color = initializeColor ( ) ,
            d = [ ] ,
            f = [ ] ,
            p = [ ] ;
      	time = 0 ;
      
      	for ( var i = 0; i &lt; vertices.length; i++ ) {
          	f [ vertices [ i ] ] = 0 ;
          	d [ vertices [ i ] ] = 0;
          	p [ vertices [ i ] ] = null ;
      	}
      	for ( i = 0; i &lt; vertices.length; i++ ) {
          	if ( color [ vertices [ i ] ] === &quot;white&quot; ) {
              	DFSVisit ( vertices [ i ], color, d, f, p)
          	}
        }  
      	return {
          	discocery : d;
          	finished : f,
          	predecessors : p
      	} ;
    } ;

    // 辅助函数
    var DFSVisit = function ( u, color, d, f, p ) {
      	console.log ( &quot;discoveryed &quot; + u ) ;
      	color [ u ] = &quot;grey&quot; ;
      	d [ u ] = ++time ;
      	var neighbors = adjList.get ( u ) ;
      	for ( var i = 0; i &lt; neighbors.length; i++ ) {
          	var w = neighbors [ i ] ;
          	if ( color [ w ] === &quot;white&quot; ) {
              	p [ w ] = u ;
              	DFSVisit ( w, color, d, f, p ) ;
          	}
      	}
      	color [ u ] = &quot;black&quot; ;
      	f [ u ] = ++time ;
      	console.log ( &quot;explored &quot; + u ) ;
    } ;
</code></pre>
<h2>拓扑排序</h2>
<p>当需要编排一些任务或步骤的执行顺序时，这称为拓扑排序（topological sorting）。</p>
<p>拓扑排序只能用于有向无环图（DAG）</p>
</div>
        </div>
      </div>
    </main>
    <footer id="footer">
      <div class="wraper">
        <p>Copyright (c) foobar</p>
      </div>
    </footer>
    <script src="../js/all.js"></script>
    <script src="../css/highlight/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script>
  </body>
</html>